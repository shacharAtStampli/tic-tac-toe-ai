<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic Tac Toe - Smart AI Battle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            text-align: center;
            max-width: 700px;
            width: 100%;
        }

        h1 {
            color: #e94560;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            color: #a0a0a0;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        .agents-info {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            gap: 20px;
        }

        .agent-card {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 15px 25px;
            flex: 1;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        .agent-card.x {
            border-color: #e94560;
        }

        .agent-card.o {
            border-color: #0ea5e9;
        }

        .agent-card h3 {
            color: #fff;
            font-size: 1.2rem;
            margin-bottom: 5px;
        }

        .agent-card.x h3 {
            color: #e94560;
        }

        .agent-card.o h3 {
            color: #0ea5e9;
        }

        .agent-card p {
            color: #888;
            font-size: 0.85rem;
        }

        .agent-card.human {
            border-style: dashed;
        }

        .agent-card.human h3::after {
            content: ' (You)';
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .agent-card.active {
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
            transform: scale(1.05);
        }

        .agent-card.o.active {
            box-shadow: 0 0 20px rgba(14, 165, 233, 0.5);
        }

        .thinking-bubble {
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.75rem;
            color: #aaa;
            min-height: 60px;
            text-align: left;
            transition: all 0.3s ease;
        }

        .thinking-bubble.active {
            color: #fff;
            background: rgba(0,0,0,0.6);
        }

        .thinking-bubble .thought {
            margin: 3px 0;
        }

        .thinking-bubble .thought.win {
            color: #4ade80;
        }

        .thinking-bubble .thought.block {
            color: #fbbf24;
        }

        .thinking-bubble .thought.strategy {
            color: #a78bfa;
        }

        .board-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
        }

        .board {
            display: grid;
            gap: 6px;
            max-width: 500px;
            width: 100%;
        }

        .cell {
            aspect-ratio: 1;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: default;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            position: relative;
        }

        .cell.clickable {
            cursor: pointer;
        }

        .cell.clickable:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }

        .cell.x {
            color: #e94560;
            text-shadow: 0 0 15px rgba(233, 69, 96, 0.5);
            border-color: rgba(233, 69, 96, 0.3);
        }

        .cell.o {
            color: #0ea5e9;
            text-shadow: 0 0 15px rgba(14, 165, 233, 0.5);
            border-color: rgba(14, 165, 233, 0.3);
        }

        .cell.winning {
            animation: pulse 0.5s ease-in-out infinite alternate;
            background: rgba(255,255,255,0.2);
        }

        .cell.threat {
            background: rgba(251, 191, 36, 0.2);
            border-color: rgba(251, 191, 36, 0.5);
        }

        .cell.opportunity {
            background: rgba(74, 222, 128, 0.2);
            border-color: rgba(74, 222, 128, 0.5);
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        .cell.new-move {
            animation: pop 0.3s ease-out;
        }

        @keyframes pop {
            0% { transform: scale(0); }
            70% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .status {
            color: #fff;
            font-size: 1.3rem;
            margin-bottom: 20px;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .status.winner {
            color: #4ade80;
            font-weight: bold;
        }

        .status.draw {
            color: #fbbf24;
        }

        .status.your-turn {
            color: #a78bfa;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            align-items: center;
        }

        .settings {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
            align-items: center;
        }

        .setting-group {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #888;
        }

        .setting-group label {
            font-size: 0.9rem;
        }

        .setting-group input, .setting-group select {
            padding: 8px 15px;
            border-radius: 6px;
            border: none;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 0.9rem;
            width: 80px;
            text-align: center;
        }

        .setting-group select {
            width: auto;
            cursor: pointer;
        }

        .setting-group input:focus {
            outline: 2px solid #e94560;
        }

        button {
            background: linear-gradient(135deg, #e94560, #c23a51);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(233, 69, 96, 0.4);
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        button.secondary {
            background: linear-gradient(135deg, #0ea5e9, #0284c7);
        }

        button.secondary:hover {
            box-shadow: 0 5px 20px rgba(14, 165, 233, 0.4);
        }

        .game-log {
            margin-top: 30px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            text-align: left;
        }

        .game-log h4 {
            color: #888;
            margin-bottom: 10px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .log-entry {
            color: #ccc;
            font-size: 0.85rem;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry.x-move {
            color: #e94560;
        }

        .log-entry.o-move {
            color: #0ea5e9;
        }

        .log-entry.result {
            color: #4ade80;
            font-weight: bold;
        }

        .log-entry.thinking {
            color: #a78bfa;
            font-style: italic;
        }

        .game-counter {
            color: #888;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }

        .board-info {
            color: #888;
            font-size: 0.85rem;
            margin-bottom: 10px;
        }

        .player-mode-info {
            color: #a78bfa;
            font-size: 0.9rem;
            margin-bottom: 15px;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Tic Tac Toe</h1>
        <p class="subtitle">Smart AI Battle - Dynamic Board Size</p>

        <div class="agents-info">
            <div class="agent-card x" id="agent-x">
                <h3 id="agent-x-name">X - Strategic Agent</h3>
                <p id="agent-x-desc">Thinks ahead, blocks threats</p>
                <div class="thinking-bubble" id="thinking-x">
                    <div class="thought">Waiting...</div>
                </div>
            </div>
            <div class="agent-card o" id="agent-o">
                <h3 id="agent-o-name">O - Defensive Agent</h3>
                <p id="agent-o-desc">Analyzes board, counters moves</p>
                <div class="thinking-bubble" id="thinking-o">
                    <div class="thought">Waiting...</div>
                </div>
            </div>
        </div>

        <div class="settings">
            <div class="setting-group">
                <label for="human-players">Human Players:</label>
                <select id="human-players">
                    <option value="0">0 (AI vs AI)</option>
                    <option value="1">1 (Human vs AI)</option>
                    <option value="2">2 (Human vs Human)</option>
                </select>
            </div>
            <div class="setting-group">
                <label for="board-size">Board Size:</label>
                <input type="number" id="board-size" min="3" max="10" value="3">
            </div>
            <div class="setting-group">
                <label for="win-length">Win Length:</label>
                <input type="number" id="win-length" min="3" max="10" value="3">
            </div>
            <div class="setting-group">
                <label for="speed">AI Speed:</label>
                <select id="speed">
                    <option value="1500">Slow</option>
                    <option value="800" selected>Normal</option>
                    <option value="400">Fast</option>
                </select>
            </div>
        </div>

        <div class="board-info" id="board-info">3x3 board - 3 in a row to win</div>
        <div class="player-mode-info" id="player-mode-info">AI vs AI - Watch the agents battle!</div>

        <div class="game-counter" id="game-counter"></div>

        <div class="status" id="status">Click "Start Game" to begin</div>

        <div class="board-container">
            <div class="board" id="board"></div>
        </div>

        <div class="controls">
            <button id="start-btn">Start Game</button>
            <button id="play-two-btn" class="secondary">Play 2 Games</button>
        </div>

        <div class="game-log">
            <h4>Game Log</h4>
            <div id="log"></div>
        </div>
    </div>

    <script>
        // Game state
        let boardSize = 3;
        let winLength = 3;
        let board = [];
        let currentPlayer = 'X';
        let gameOver = false;
        let isPlaying = false;
        let currentGameNumber = 0;
        let totalGames = 0;
        let winPatterns = [];
        let humanPlayers = 0; // 0 = AI vs AI, 1 = Human vs AI, 2 = Human vs Human
        let waitingForHuman = false;

        // Player configuration
        let players = {
            'X': { isHuman: false, name: 'Strategic Agent', desc: 'Thinks ahead, blocks threats' },
            'O': { isHuman: false, name: 'Defensive Agent', desc: 'Analyzes board, counters moves' }
        };

        // DOM elements
        const boardEl = document.getElementById('board');
        const statusEl = document.getElementById('status');
        const logEl = document.getElementById('log');
        const startBtn = document.getElementById('start-btn');
        const playTwoBtn = document.getElementById('play-two-btn');
        const speedSelect = document.getElementById('speed');
        const boardSizeInput = document.getElementById('board-size');
        const winLengthInput = document.getElementById('win-length');
        const humanPlayersSelect = document.getElementById('human-players');
        const agentX = document.getElementById('agent-x');
        const agentO = document.getElementById('agent-o');
        const agentXName = document.getElementById('agent-x-name');
        const agentOName = document.getElementById('agent-o-name');
        const agentXDesc = document.getElementById('agent-x-desc');
        const agentODesc = document.getElementById('agent-o-desc');
        const thinkingX = document.getElementById('thinking-x');
        const thinkingO = document.getElementById('thinking-o');
        const gameCounter = document.getElementById('game-counter');
        const boardInfo = document.getElementById('board-info');
        const playerModeInfo = document.getElementById('player-mode-info');

        function getSpeed() {
            return parseInt(speedSelect.value);
        }

        function getPositionName(index) {
            const row = Math.floor(index / boardSize);
            const col = index % boardSize;
            return `(${row + 1}, ${col + 1})`;
        }

        function updatePlayerConfig() {
            humanPlayers = parseInt(humanPlayersSelect.value);
            
            if (humanPlayers === 0) {
                players.X = { isHuman: false, name: 'Strategic Agent', desc: 'Thinks ahead, blocks threats' };
                players.O = { isHuman: false, name: 'Defensive Agent', desc: 'Analyzes board, counters moves' };
                playerModeInfo.textContent = 'AI vs AI - Watch the agents battle!';
            } else if (humanPlayers === 1) {
                players.X = { isHuman: true, name: 'Player 1', desc: 'Click a cell to place your mark' };
                players.O = { isHuman: false, name: 'AI Opponent', desc: 'Strategic AI agent' };
                playerModeInfo.textContent = 'Human (X) vs AI (O) - You play first!';
            } else {
                players.X = { isHuman: true, name: 'Player 1', desc: 'Click a cell to place your mark' };
                players.O = { isHuman: true, name: 'Player 2', desc: 'Click a cell to place your mark' };
                playerModeInfo.textContent = 'Human vs Human - Take turns!';
            }
            
            // Update UI
            agentXName.textContent = `X - ${players.X.name}`;
            agentOName.textContent = `O - ${players.O.name}`;
            agentXDesc.textContent = players.X.desc;
            agentODesc.textContent = players.O.desc;
            
            agentX.classList.toggle('human', players.X.isHuman);
            agentO.classList.toggle('human', players.O.isHuman);
            
            // Update thinking bubbles
            if (players.X.isHuman) {
                thinkingX.innerHTML = '<div class="thought">Your turn - click a cell!</div>';
            }
            if (players.O.isHuman) {
                thinkingO.innerHTML = '<div class="thought">Your turn - click a cell!</div>';
            }
        }

        // Generate all win patterns for current board size and win length
        function generateWinPatterns() {
            winPatterns = [];
            const size = boardSize;
            const len = winLength;

            // Rows
            for (let row = 0; row < size; row++) {
                for (let startCol = 0; startCol <= size - len; startCol++) {
                    const pattern = [];
                    for (let i = 0; i < len; i++) {
                        pattern.push(row * size + startCol + i);
                    }
                    winPatterns.push(pattern);
                }
            }

            // Columns
            for (let col = 0; col < size; col++) {
                for (let startRow = 0; startRow <= size - len; startRow++) {
                    const pattern = [];
                    for (let i = 0; i < len; i++) {
                        pattern.push((startRow + i) * size + col);
                    }
                    winPatterns.push(pattern);
                }
            }

            // Diagonals (top-left to bottom-right)
            for (let row = 0; row <= size - len; row++) {
                for (let col = 0; col <= size - len; col++) {
                    const pattern = [];
                    for (let i = 0; i < len; i++) {
                        pattern.push((row + i) * size + (col + i));
                    }
                    winPatterns.push(pattern);
                }
            }

            // Diagonals (top-right to bottom-left)
            for (let row = 0; row <= size - len; row++) {
                for (let col = len - 1; col < size; col++) {
                    const pattern = [];
                    for (let i = 0; i < len; i++) {
                        pattern.push((row + i) * size + (col - i));
                    }
                    winPatterns.push(pattern);
                }
            }
        }

        function createBoard() {
            boardEl.innerHTML = '';
            boardEl.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
            
            // Adjust cell font size based on board size
            const fontSize = Math.max(1.5, 4 - (boardSize - 3) * 0.5);
            
            for (let i = 0; i < boardSize * boardSize; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.index = i;
                cell.style.fontSize = `${fontSize}rem`;
                cell.addEventListener('click', () => handleCellClick(i));
                boardEl.appendChild(cell);
            }
        }

        function handleCellClick(index) {
            // Only allow clicks if it's a human's turn and the cell is empty
            if (!isPlaying || gameOver || !waitingForHuman) return;
            if (!players[currentPlayer].isHuman) return;
            if (board[index] !== '') return;
            
            // Make the human move
            makeHumanMove(index);
        }

        async function makeHumanMove(index) {
            waitingForHuman = false;
            
            const playerName = players[currentPlayer].name;
            board[index] = currentPlayer;
            log(`${playerName} (${currentPlayer}) ‚Üí ${getPositionName(index)}`, currentPlayer === 'X' ? 'x-move' : 'o-move');
            
            updateBoard();
            const cells = document.querySelectorAll('.cell');
            cells[index].classList.add('new-move');
            
            // Update thinking bubble
            const thinkingEl = currentPlayer === 'X' ? thinkingX : thinkingO;
            thinkingEl.innerHTML = `<div class="thought">Placed at ${getPositionName(index)}</div>`;
            
            // Check game end conditions
            if (await checkGameEnd()) return;
            
            // Switch player and continue
            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
            await new Promise(resolve => setTimeout(resolve, 300));
            await playTurn();
        }

        function log(message, className = '') {
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + className;
            entry.textContent = message;
            logEl.insertBefore(entry, logEl.firstChild);
        }

        function updateThinking(player, thoughts) {
            const thinkingEl = player === 'X' ? thinkingX : thinkingO;
            thinkingEl.innerHTML = thoughts.map(t => 
                `<div class="thought ${t.type}">${t.text}</div>`
            ).join('');
        }

        function clearThinking() {
            if (players.X.isHuman) {
                thinkingX.innerHTML = '<div class="thought">Your turn - click a cell!</div>';
            } else {
                thinkingX.innerHTML = '<div class="thought">Waiting...</div>';
            }
            if (players.O.isHuman) {
                thinkingO.innerHTML = '<div class="thought">Your turn - click a cell!</div>';
            } else {
                thinkingO.innerHTML = '<div class="thought">Waiting...</div>';
            }
            thinkingX.classList.remove('active');
            thinkingO.classList.remove('active');
        }

        function updateBoard() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach((cell, i) => {
                cell.textContent = board[i];
                cell.className = 'cell';
                const fontSize = Math.max(1.5, 4 - (boardSize - 3) * 0.5);
                cell.style.fontSize = `${fontSize}rem`;
                if (board[i] === 'X') cell.classList.add('x');
                if (board[i] === 'O') cell.classList.add('o');
                
                // Make empty cells clickable if waiting for human
                if (board[i] === '' && waitingForHuman && players[currentPlayer].isHuman) {
                    cell.classList.add('clickable');
                }
            });
        }

        function highlightCells(indices, className) {
            const cells = document.querySelectorAll('.cell');
            indices.forEach(i => cells[i].classList.add(className));
        }

        function clearHighlights() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.classList.remove('threat', 'opportunity', 'clickable');
            });
        }

        function highlightWinner(pattern) {
            const cells = document.querySelectorAll('.cell');
            pattern.forEach(i => cells[i].classList.add('winning'));
        }

        function checkWinner() {
            for (const pattern of winPatterns) {
                const first = board[pattern[0]];
                if (first && pattern.every(i => board[i] === first)) {
                    return { winner: first, pattern };
                }
            }
            return null;
        }

        function isDraw() {
            return !board.includes('') && !checkWinner();
        }

        function getAvailableMoves() {
            return board.map((cell, i) => cell === '' ? i : null).filter(i => i !== null);
        }

        // Check if a player can still potentially win
        function canPlayerWin(player) {
            const opponent = player === 'X' ? 'O' : 'X';
            
            for (const pattern of winPatterns) {
                const cells = pattern.map(i => board[i]);
                // A pattern is still winnable if opponent hasn't placed in it
                const hasOpponent = cells.some(c => c === opponent);
                if (!hasOpponent) {
                    return true; // This pattern is still open for player
                }
            }
            return false; // All patterns blocked
        }
        
        // Check if the game is still winnable by anyone
        function isGameStillWinnable() {
            const xCanWin = canPlayerWin('X');
            const oCanWin = canPlayerWin('O');
            return { xCanWin, oCanWin, anyCanWin: xCanWin || oCanWin };
        }

        // Check if a player can win in one move - returns the winning position or null
        function findWinningMove(player) {
            const allWins = findAllWinningMoves(player);
            return allWins.length > 0 ? allWins[0] : null;
        }
        
        // Find ALL winning moves (not just the first one)
        function findAllWinningMoves(player) {
            const winningMoves = [];
            for (const pattern of winPatterns) {
                const cells = pattern.map(i => board[i]);
                const playerCount = cells.filter(c => c === player).length;
                const emptyCount = cells.filter(c => c === '').length;
                
                if (playerCount === winLength - 1 && emptyCount === 1) {
                    const emptyIndex = pattern.find(i => board[i] === '');
                    if (!winningMoves.find(m => m.position === emptyIndex)) {
                        winningMoves.push({ position: emptyIndex, pattern });
                    }
                }
            }
            return winningMoves;
        }

        // Find all threats (positions where opponent could win)
        function findThreats(player) {
            const opponent = player === 'X' ? 'O' : 'X';
            const threats = [];
            
            for (const pattern of winPatterns) {
                const cells = pattern.map(i => board[i]);
                const opponentCount = cells.filter(c => c === opponent).length;
                const emptyCount = cells.filter(c => c === '').length;
                
                if (opponentCount === winLength - 1 && emptyCount === 1) {
                    const emptyIndex = pattern.find(i => board[i] === '');
                    if (!threats.find(t => t.position === emptyIndex)) {
                        threats.push({ position: emptyIndex, pattern });
                    }
                }
            }
            return threats;
        }

        // Evaluate a position's strategic value
        function evaluatePosition(pos, player, randomFactor = 0) {
            let score = 0;
            const opponent = player === 'X' ? 'O' : 'X';
            
            for (const pattern of winPatterns) {
                if (!pattern.includes(pos)) continue;
                
                const cells = pattern.map(i => board[i]);
                const playerCount = cells.filter(c => c === player).length;
                const opponentCount = cells.filter(c => c === opponent).length;
                const emptyCount = cells.filter(c => c === '').length;
                
                // Only count patterns that are still winnable
                if (opponentCount === 0) {
                    score += Math.pow(10, playerCount);
                }
            }
            
            // Center positions are more valuable
            const centerRow = Math.floor(boardSize / 2);
            const centerCol = Math.floor(boardSize / 2);
            const row = Math.floor(pos / boardSize);
            const col = pos % boardSize;
            const distFromCenter = Math.abs(row - centerRow) + Math.abs(col - centerCol);
            score += (boardSize - distFromCenter) * 2;
            
            // Add randomness to make games varied
            score += Math.random() * randomFactor;
            
            return score;
        }

        // Find strategic moves with randomness for variety
        function findStrategicMove(player, randomFactor = 15) {
            const available = getAvailableMoves();
            const opponent = player === 'X' ? 'O' : 'X';
            
            // Check for creating a fork (multiple ways to win)
            const forkMoves = [];
            
            for (const pos of available) {
                board[pos] = player;
                let winningPaths = 0;
                
                for (const pattern of winPatterns) {
                    const cells = pattern.map(i => board[i]);
                    const playerCount = cells.filter(c => c === player).length;
                    const emptyCount = cells.filter(c => c === '').length;
                    if (playerCount === winLength - 1 && emptyCount === 1) {
                        winningPaths++;
                    }
                }
                
                board[pos] = '';
                
                if (winningPaths >= 2) {
                    forkMoves.push({ pos, paths: winningPaths });
                }
            }
            
            if (forkMoves.length > 0) {
                // Randomly pick among fork moves (weighted by path count)
                const bestForkCount = Math.max(...forkMoves.map(f => f.paths));
                const bestForks = forkMoves.filter(f => f.paths === bestForkCount);
                const chosen = bestForks[Math.floor(Math.random() * bestForks.length)];
                return { position: chosen.pos, reason: `Creating fork with ${chosen.paths} win paths!` };
            }
            
            // Block opponent's fork - collect all blocking moves
            const blockingMoves = [];
            for (const pos of available) {
                board[pos] = opponent;
                let opponentWinPaths = 0;
                
                for (const pattern of winPatterns) {
                    const cells = pattern.map(i => board[i]);
                    const oppCount = cells.filter(c => c === opponent).length;
                    const emptyCount = cells.filter(c => c === '').length;
                    if (oppCount === winLength - 1 && emptyCount === 1) {
                        opponentWinPaths++;
                    }
                }
                
                board[pos] = '';
                
                if (opponentWinPaths >= 2) {
                    blockingMoves.push({ pos, paths: opponentWinPaths });
                }
            }
            
            if (blockingMoves.length > 0) {
                // Randomly pick among blocking moves
                const chosen = blockingMoves[Math.floor(Math.random() * blockingMoves.length)];
                return { position: chosen.pos, reason: 'Blocking opponent fork!' };
            }
            
            // Evaluate all positions with randomness and pick the best
            const scoredMoves = available.map(pos => ({
                pos,
                score: evaluatePosition(pos, player, randomFactor)
            }));
            
            // Sort by score descending
            scoredMoves.sort((a, b) => b.score - a.score);
            
            // Pick from top moves with some randomness
            const topScore = scoredMoves[0].score;
            const threshold = topScore * 0.85; // Consider moves within 15% of best
            const topMoves = scoredMoves.filter(m => m.score >= threshold);
            const chosen = topMoves[Math.floor(Math.random() * topMoves.length)];
            const bestPos = chosen.pos;
            
            // Determine reason based on position
            const row = Math.floor(bestPos / boardSize);
            const col = bestPos % boardSize;
            const isCenter = row === Math.floor(boardSize / 2) && col === Math.floor(boardSize / 2);
            const isCorner = (row === 0 || row === boardSize - 1) && (col === 0 || col === boardSize - 1);
            
            let reason = 'Strategic position';
            if (isCenter) reason = 'Taking center - strongest position';
            else if (isCorner) reason = 'Taking corner - good control';
            
            return { position: bestPos, reason };
        }

        // Smart Agent - analyzes board and makes intelligent decisions
        // Each agent has different personality traits for variety
        function smartAgentMove(player) {
            const thoughts = [];
            const opponent = player === 'X' ? 'O' : 'X';
            
            // Different personalities: X is more aggressive, O is more defensive
            const personality = player === 'X' 
                ? { name: 'Aggressive', randomFactor: 20, riskTaker: Math.random() > 0.3 }
                : { name: 'Cautious', randomFactor: 15, riskTaker: Math.random() > 0.6 };
            
            thoughts.push({ text: `Analyzing ${boardSize}x${boardSize} board (${personality.name} mode)...`, type: '' });
            
            // Check if game is still winnable
            const winnableStatus = isGameStillWinnable();
            if (!winnableStatus.anyCanWin) {
                thoughts.push({ text: `Board analysis: NO WINNING PATHS LEFT`, type: 'block' });
                thoughts.push({ text: `Game should be declared a draw!`, type: 'block' });
                // Return any available move (game will end as draw)
                const available = getAvailableMoves();
                return { move: available[0], thoughts, reason: 'NO WINS POSSIBLE' };
            }
            
            // Report winning possibilities
            if (!winnableStatus.xCanWin) {
                thoughts.push({ text: `X has no winning paths left`, type: 'block' });
            }
            if (!winnableStatus.oCanWin) {
                thoughts.push({ text: `O has no winning paths left`, type: 'block' });
            }
            
            // Step 1: Check if I can win
            const myWins = findAllWinningMoves(player);
            if (myWins.length > 0) {
                // Randomly pick among winning moves for variety
                const myWin = myWins[Math.floor(Math.random() * myWins.length)];
                thoughts.push({ text: `Found winning move at ${getPositionName(myWin.position)}!`, type: 'win' });
                return { move: myWin.position, thoughts, reason: 'WINNING MOVE' };
            }
            thoughts.push({ text: `No immediate win available`, type: '' });
            
            // Step 2: Check if opponent can win - MUST BLOCK
            const threats = findThreats(player);
            if (threats.length > 0) {
                // Randomly pick which threat to block if multiple
                const threat = threats[Math.floor(Math.random() * threats.length)];
                thoughts.push({ text: `DANGER! ${opponent} can win at ${getPositionName(threat.position)}`, type: 'block' });
                thoughts.push({ text: `Must block immediately!`, type: 'block' });
                
                if (threats.length > 1) {
                    thoughts.push({ text: `${threats.length} threats detected! Trouble...`, type: 'block' });
                }
                
                return { move: threat.position, thoughts, reason: 'BLOCKING THREAT' };
            }
            thoughts.push({ text: `No immediate threats from ${opponent}`, type: '' });
            
            // Count remaining winning paths
            const myPaths = countWinningPaths(player);
            const oppPaths = countWinningPaths(opponent);
            thoughts.push({ text: `Winning paths: Me=${myPaths}, ${opponent}=${oppPaths}`, type: 'strategy' });
            
            // Step 3: Make strategic move with personality-based randomness
            const strategic = findStrategicMove(player, personality.randomFactor);
            thoughts.push({ text: strategic.reason, type: 'strategy' });
            
            return { move: strategic.position, thoughts, reason: strategic.reason };
        }
        
        // Count how many winning paths are still open for a player
        function countWinningPaths(player) {
            const opponent = player === 'X' ? 'O' : 'X';
            let count = 0;
            
            for (const pattern of winPatterns) {
                const cells = pattern.map(i => board[i]);
                const hasOpponent = cells.some(c => c === opponent);
                if (!hasOpponent) {
                    count++;
                }
            }
            return count;
        }

        function updateAgentHighlight() {
            agentX.classList.toggle('active', currentPlayer === 'X' && !gameOver);
            agentO.classList.toggle('active', currentPlayer === 'O' && !gameOver);
            thinkingX.classList.toggle('active', currentPlayer === 'X' && !gameOver);
            thinkingO.classList.toggle('active', currentPlayer === 'O' && !gameOver);
        }

        async function checkGameEnd() {
            const winResult = checkWinner();
            if (winResult) {
                gameOver = true;
                highlightWinner(winResult.pattern);
                const winnerName = `${players[winResult.winner].name} (${winResult.winner})`;
                statusEl.textContent = `${winnerName} wins!`;
                statusEl.className = 'status winner';
                log(`üèÜ ${winnerName} wins!`, 'result');
                updateAgentHighlight();
                clearThinking();
                enableControls();
                return true;
            }

            // Check if the game is still winnable
            const winnableStatus = isGameStillWinnable();
            if (!winnableStatus.anyCanWin) {
                gameOver = true;
                const emptyCount = board.filter(c => c === '').length;
                statusEl.textContent = `Draw detected early! No possible wins remaining.`;
                statusEl.className = 'status draw';
                log(`üîç Analysis: Neither player can win anymore`, 'thinking');
                log(`ü§ù Early draw - ${emptyCount} empty cells but no winning paths!`, 'result');
                updateAgentHighlight();
                clearThinking();
                enableControls();
                return true;
            }

            if (isDraw()) {
                gameOver = true;
                statusEl.textContent = "It's a draw! Both played well!";
                statusEl.className = 'status draw';
                log("ü§ù Game ended in a draw - great defense!", 'result');
                updateAgentHighlight();
                clearThinking();
                enableControls();
                return true;
            }
            
            return false;
        }

        async function playTurn() {
            if (gameOver) return;

            updateAgentHighlight();
            clearHighlights();
            
            const playerConfig = players[currentPlayer];
            const playerName = `${playerConfig.name} (${currentPlayer})`;
            
            if (playerConfig.isHuman) {
                // Human's turn - wait for click
                waitingForHuman = true;
                statusEl.textContent = `${playerName}'s turn - click a cell!`;
                statusEl.className = 'status your-turn';
                
                const thinkingEl = currentPlayer === 'X' ? thinkingX : thinkingO;
                thinkingEl.innerHTML = '<div class="thought">Your turn!</div><div class="thought strategy">Click an empty cell to place your mark</div>';
                
                updateBoard(); // This will add 'clickable' class to empty cells
                return; // Wait for human input
            }
            
            // AI's turn
            statusEl.textContent = `${playerName} is thinking...`;
            
            // Show thinking process
            await new Promise(resolve => setTimeout(resolve, getSpeed() / 2));
            
            const result = smartAgentMove(currentPlayer);
            updateThinking(currentPlayer, result.thoughts);
            
            // Highlight threats/opportunities on board
            const threats = findThreats(currentPlayer);
            const myWins = findAllWinningMoves(currentPlayer);
            
            if (myWins.length > 0) {
                highlightCells(myWins.map(w => w.position), 'opportunity');
            }
            if (threats.length > 0) {
                highlightCells(threats.map(t => t.position), 'threat');
            }
            
            await new Promise(resolve => setTimeout(resolve, getSpeed() / 2));
            
            // Make the move
            board[result.move] = currentPlayer;
            log(`${playerName} ‚Üí ${getPositionName(result.move)} (${result.reason})`, currentPlayer === 'X' ? 'x-move' : 'o-move');
            
            updateBoard();
            const cells = document.querySelectorAll('.cell');
            cells[result.move].classList.add('new-move');
            clearHighlights();

            // Check game end conditions
            if (await checkGameEnd()) return;

            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
            
            await new Promise(resolve => setTimeout(resolve, 200));
            await playTurn();
        }

        function initializeGame() {
            boardSize = Math.max(3, Math.min(10, parseInt(boardSizeInput.value) || 3));
            winLength = Math.max(3, Math.min(boardSize, parseInt(winLengthInput.value) || 3));
            
            // Update inputs to show validated values
            boardSizeInput.value = boardSize;
            winLengthInput.value = winLength;
            
            boardInfo.textContent = `${boardSize}x${boardSize} board - ${winLength} in a row to win`;
            
            board = Array(boardSize * boardSize).fill('');
            generateWinPatterns();
            createBoard();
            updateBoard();
            updatePlayerConfig();
        }

        function resetGame() {
            initializeGame();
            currentPlayer = 'X';
            gameOver = false;
            waitingForHuman = false;
            clearHighlights();
            clearThinking();
            statusEl.textContent = 'Starting...';
            statusEl.className = 'status';
            updateAgentHighlight();
        }

        async function startGame() {
            if (isPlaying) return;
            
            isPlaying = true;
            startBtn.disabled = true;
            playTwoBtn.disabled = true;
            boardSizeInput.disabled = true;
            winLengthInput.disabled = true;
            humanPlayersSelect.disabled = true;
            
            resetGame();
            log(`--- New Game (${boardSize}x${boardSize}, ${winLength} to win) ---`, '');
            
            await new Promise(resolve => setTimeout(resolve, 500));
            await playTurn();
            
            // Only re-enable if game is over (not waiting for human)
            if (gameOver) {
                isPlaying = false;
                startBtn.disabled = false;
                playTwoBtn.disabled = false;
                boardSizeInput.disabled = false;
                winLengthInput.disabled = false;
                humanPlayersSelect.disabled = false;
            }
        }

        async function playMultipleGames(count) {
            if (isPlaying) return;
            if (humanPlayers > 0) {
                // Can't auto-play multiple games with human players
                alert('Multiple games mode is only available for AI vs AI (0 human players)');
                return;
            }
            
            totalGames = count;
            startBtn.disabled = true;
            playTwoBtn.disabled = true;
            boardSizeInput.disabled = true;
            winLengthInput.disabled = true;
            humanPlayersSelect.disabled = true;
            
            for (let i = 1; i <= count; i++) {
                currentGameNumber = i;
                gameCounter.textContent = `Game ${i} of ${count}`;
                
                isPlaying = true;
                resetGame();
                log(`--- Game ${i} of ${count} (${boardSize}x${boardSize}) ---`, '');
                
                await new Promise(resolve => setTimeout(resolve, 500));
                await playTurn();
                
                isPlaying = false;
                
                if (i < count) {
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }
            
            gameCounter.textContent = `Completed ${count} games`;
            startBtn.disabled = false;
            playTwoBtn.disabled = false;
            boardSizeInput.disabled = false;
            winLengthInput.disabled = false;
            humanPlayersSelect.disabled = false;
        }

        // Re-enable controls when game ends (for human games)
        function enableControls() {
            isPlaying = false;
            startBtn.disabled = false;
            playTwoBtn.disabled = false;
            boardSizeInput.disabled = false;
            winLengthInput.disabled = false;
            humanPlayersSelect.disabled = false;
        }

        // Update win length max when board size changes
        boardSizeInput.addEventListener('change', () => {
            const size = parseInt(boardSizeInput.value) || 3;
            winLengthInput.max = size;
            if (parseInt(winLengthInput.value) > size) {
                winLengthInput.value = size;
            }
            boardInfo.textContent = `${size}x${size} board - ${winLengthInput.value} in a row to win`;
        });

        winLengthInput.addEventListener('change', () => {
            const len = parseInt(winLengthInput.value) || 3;
            const size = parseInt(boardSizeInput.value) || 3;
            boardInfo.textContent = `${size}x${size} board - ${len} in a row to win`;
        });

        humanPlayersSelect.addEventListener('change', updatePlayerConfig);

        // Event listeners
        startBtn.addEventListener('click', startGame);
        playTwoBtn.addEventListener('click', () => playMultipleGames(2));

        // Initialize
        initializeGame();
    </script>
</body>
</html>
